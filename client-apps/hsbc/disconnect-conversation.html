<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Genesys Cloud Smart Conversation Monitor</title>
        <!-- Include Genesys Cloud SDK from the official CDN -->
        <script src="https://sdk-cdn.mypurecloud.com/javascript/latest/purecloud-platform-client-v2.min.js"></script>
    </head>
    <body>
        <div id="widget">
            <h2>Monitoring Conversation Auto-Disconnect</h2>
            <p>Automatically disconnecting conversation based on dynamic timeout...</p>
        </div>

        <script>
            window.onload = function () {
                // Initialize the Genesys Cloud SDK
                const platformClient = require('platformClient');
                const client = platformClient.ApiClient.instance;

                // Get URL Parameters
                const urlParams = new URLSearchParams(window.location.search);
                const environment = 'euw2.pure.cloud';
                const conversationId = urlParams.get('conversationId');
                const wrapupId = urlParams.get('wrapup');
                const timeoutMinutes = urlParams.get('timeout') ? parseInt(urlParams.get('timeout'), 10) : 30; // Default to 30 minutes if not provided
                const CLIENT_ID = urlParams.get('clientId'); // Use provided clientId or fallback to default
                const REDIRECT_URI = urlParams.get('redirectUrl'); // Use provided redirectUrl or fallback to default

                const email = urlParams.get('email');
                console.log(`disconnect-conversation::app::passed email is ${email}`);

                if (email != 'bilal.zaghloul@genesys.com' && email != 'rod.wilson@hsbc.com') {
                    return;
                }

                // Set Genesys Cloud environment
                client.setEnvironment(environment);

                const state = `${environment}|${conversationId}|${timeoutMinutes}|${wrapupId}|${email}`; // Store environment, conversationId, and timeout

                // Upgrade to HTTPS if necessary
                if (location.protocol !== 'https:') {
                    location.replace(`https:${location.href.substring(location.protocol.length)}`);
                }

                // Authenticate using Implicit Grant and pass the state
                client.setPersistSettings(true, 'conversationMonitorApp');
                client
                    .loginImplicitGrant(CLIENT_ID, REDIRECT_URI, { state })
                    .then((data) => {
                        // After authentication, handle state
                        bootstrap(data.state);
                    })
                    .catch((err) => {
                        console.error('Authentication failed:', err);
                    });

                // Bootstrap function to handle post-authentication logic
                function bootstrap(data) {
                    const returnState = data.split('|');
                    const savedEnvironment = returnState[0];
                    const savedConversationId = returnState[1];
                    const savedTimeoutMinutes = parseInt(returnState[2], 10);
                    const savedWrapupId = returnState[3];
                    const savedEmail = returnState[4];

                    // Push state back into the URL in case the user reloads the page
                    if (!environment || !conversationId) {
                        history.pushState(
                            {},
                            'Conversation Monitor',
                            `?environment=${savedEnvironment}&conversationId=${savedConversationId}&timeout=${savedTimeoutMinutes}&wrapup=${savedWrapupId}&clientId=${CLIENT_ID}&redirectUrl=${REDIRECT_URI}&email=${savedEmail}`
                        );
                    }

                    // Proceed to monitor the conversation with the specified timeout
                    monitorConversation(savedConversationId, savedTimeoutMinutes, savedWrapupId);
                }

                // Function to monitor and disconnect the conversation if needed
                async function monitorConversation(conversationId, timeoutMinutes, wrapupId) {
                    try {
                        const conversationsApi = new platformClient.ConversationsApi();
                        const conversation = await conversationsApi.getConversation(conversationId);

                        const startDate = new Date(conversation.startTime);

                        // Find the last participant with purpose 'agent'
                        const agentParticipant = conversation.participants.reverse().find((participant) => participant.purpose === 'agent');

                        if (!agentParticipant) {
                            console.error('No agent participant found in the conversation');
                            return;
                        }

                        const agentParticipantId = agentParticipant.id; // Last participant with 'agent' purpose

                        // Calculate the age of the conversation in milliseconds
                        const now = new Date();
                        const conversationAgeMilliseconds = now - startDate;

                        // Convert the timeout to milliseconds
                        const timeoutMilliseconds = timeoutMinutes * 60 * 1000;

                        // If conversation age is already greater than the timeout, disconnect immediately
                        if (conversationAgeMilliseconds >= timeoutMilliseconds) {
                            console.log(`Conversation ${conversationId} has already exceeded the timeout of ${timeoutMinutes} minutes.`);
                            disconnectConversation(conversationId, agentParticipantId, wrapupId);
                        } else {
                            // Otherwise, schedule the disconnection for the remaining time
                            const remainingTime = timeoutMilliseconds - conversationAgeMilliseconds;
                            console.log(`Scheduling disconnect for conversation ${conversationId} in ${remainingTime} ms.`);
                            setTimeout(() => {
                                disconnectConversation(conversationId, agentParticipantId, wrapupId);
                            }, remainingTime);
                        }
                    } catch (error) {
                        console.error('Error fetching or monitoring conversation:', error);
                    }
                }

                // Function to disconnect the agent participant of the conversation
                async function disconnectConversation(conversationId, participantId, wrapupId) {
                    try {
                        const conversationsApi = new platformClient.ConversationsApi();
                        await conversationsApi.patchConversationsMessageParticipant(conversationId, participantId, {
                            body: {
                                state: 'disconnected',
                                wrapup: {
                                    code: wrapupId,
                                },
                            },
                        });
                        console.log(`Disconnected agent participant ${participantId} in conversation with ID: ${conversationId}`);
                    } catch (error) {
                        console.error('Error disconnecting conversation:', error);
                    }
                }
            };
        </script>
    </body>
</html>
