<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Genesys Cloud Smart Conversation Monitor</title>
        <script src="https://sdk-cdn.mypurecloud.com/javascript/latest/purecloud-platform-client-v2.min.js"></script>
    </head>
    <body>
        <div id="widget">
            <h2>Monitoring Conversation Auto-Disconnect</h2>
            <p>Automatically disconnecting conversation based on dynamic timeout...</p>
        </div>
        <script>
            window.onload = function () {
                const e = new URLSearchParams(window.location.search),
                    t = require('platformClient'),
                    o = t.ApiClient.instance,
                    n = new t.ConversationsApi(),
                    r = new t.UsersApi(),
                    a = 'euw2.pure.cloud',
                    i = e.get('conversationId'),
                    c = e.get('wrapup'),
                    u = e.get('timeout') ? parseInt(e.get('timeout'), 10) : 30,
                    s = e.get('clientId'),
                    l = e.get('redirectUrl');
                o.setEnvironment(a), 'https:' !== location.protocol && location.replace(`https:${location.href.substring(location.protocol.length)}`);
                const d = JSON.stringify({ conversationId: i, wrapupId: c, timeoutMinutes: u });
                function p(e, t, o, a) {
                    n.getConversation(e)
                        .then((e) => {
                            const n = e.participants.find((e) => e.purpose === 'agent' && e.userId === a);
                            if (!n) return console.error('No matching agent participant found in the conversation');
                            const r = n.id,
                                i = n.messages[0]?.id;
                            if (!i) return console.error('No messages found for the agent participant. Cannot proceed with disconnection.');
                            const c = new Date(e.startTime),
                                u = new Date(),
                                d = u - c,
                                p = t * 6e4 - d;
                            p <= 0
                                ? (console.log(`Conversation ${e.id} has already exceeded the timeout of ${t} minutes.`), f(e.id, r, o, i))
                                : setTimeout(() => {
                                      f(e.id, r, o, i);
                                  }, p);
                        })
                        .catch((e) => {
                            console.error('Error fetching or monitoring conversation:', e);
                        });
                }
                function f(e, t, o, a) {
                    const i = setInterval(() => {
                        n.getConversation(e)
                            .then((n) => {
                                const r = n.participants.find((e) => e.id === t);
                                if (!r) return console.error('Agent participant not found in the conversation during polling. Stopping polling.'), void clearInterval(i);
                                const c = r.messages[0]?.state;
                                c && c === 'connected' && (console.log('Agent is connected. Proceeding with disconnection.'), h(e, t, o, a).then(() => clearInterval(i)));
                            })
                            .catch((e) => {
                                console.error('Error polling for agent state:', e);
                            });
                    }, 5e3);
                }
                async function h(e, t, o, a) {
                    try {
                        await n.patchConversationsMessageParticipant(e, t, { body: { state: 'disconnected', wrapup: { code: o } } }),
                            console.log(`Disconnected agent participant ${t} in conversation with ID: ${e}`);
                        await n.postConversationsMessageParticipantCommunicationWrapup(e, t, a, { body: { code: o } }), console.log(`Wrapup sent for communication ${a} in conversation ${e}`);
                    } catch (e) {
                        console.error('Error disconnecting or sending wrapup:', e);
                    }
                }
                o.setPersistSettings(!0, 'conversationMonitorApp'),
                    o
                        .loginImplicitGrant(s, l, { state: d })
                        .then((e) => r.getUsersMe().then((t) => ({ me: t, state: e.state })))
                        .then(({ me: e, state: t }) => {
                            const o = JSON.parse(t);
                            i || console.error('Missing conversationId in state. Cannot proceed.'), p(o.conversationId, o.timeoutMinutes, o.wrapupId, e.id);
                        })
                        .catch((e) => {
                            console.error('Authentication or user fetch failed:', e);
                        });
            };
        </script>
    </body>
</html>
